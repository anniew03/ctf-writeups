# quickprime

## Summary

Challenge description:

```  Behold: my revolutionary new algorithm to generate primes QUICKLY and SECURELY.  ```

This challenge provides a netcat connection that randomizes parameters for a linear congruential generator that then generates two prime numbers used to implement RSA
to encrypt the flag. The vulnerability in this cryptographic algorithm lies in the predictability of linear congruential sequences, resulting in a weak implementation 
of RSA that can be cracked by factoring the modulus $n$.

**Artifacts:**
* chall.py: encryption program provided by challenge authors, from https://github.com/uclaacm/lactf-archive/blob/main/2025/crypto/quickprime/

## Context

The ‘quickprime’ challenge is provided with a domain and port used to netcat to the 
encryption server, as well as the source code for the server which reveals that the primes are being generated by a linear congruential generator.

Upon connecting to the host, the program will generate random values using the secrets module for $a$ and $c$, ensuring that they satisfy a valid LCG where $m = 2^{512}$, and then print $a$, $c$, and $m$ out.

The LCG is seeded with a random 512-bit value, and the LCG is iterated a random number of times with a 16-bit value, both the seed and initial iterations are generated as well with the secrets module.

As the LCG is used to generate numbers, the program checks if each number is prime. Once it has generated 2 prime numbers $p$ and $q$, it uses these values to produce $n = pq$ and prints $n$

RSA is implemented with the public key $e = 65537$ and the flag is encrypted using RSA, the resulting ciphertext is also printed out by the program.

## Vulnerability

Any pseudo random number generator (PRNG) like LCG’s are not truly random and can be easily predicted with just a few outputs. Instead, only cryptographically secure random number
generators should be used, and entropy analysis should be performed to ensure randomness of generated numbers. As a general rule of thumb, it is not advised to create your own cryptographic schema.

As in the name, LCG’s are linear and are thus trivial to break because of the predictability of outputs.

Each term in LCG is generated by $X_{i+1} = aX_{i} + c \ mod \ m$. In a sequence these inputs can be seen as:

$X_{i+2} = a(aX_{i} + c) + c\ mod\ m = a^2X_{i} + c(a+1)\ mod \ m$

$X_{i+3} = a(a^2X_{i} + c(a+1)) + c\ mod\ m = a^3X_{i} + c(a^2 + a + 1) \ mod\ m$

$X_{i+4} = a(a^3X_{i} + c(a^2 + a + 1)) + c\ mod\ m = a^4X_{i} + c(a^3 + a^2 + a + 1)\ mod\ m$ 


Each term in the sequence is a linear output of the i-th element before it. As such, each $X_{i+k}$ for any $k$ integer, can be represented as $ap(X_i) + cp\ mod\ m$, where

$ap = a^k\ mod\ m$

$cp = c(\sum_{j=0}^{i - 1} a^{j}\ mod\ m)$


Using this simplification of arbitrary terms, we can represent $q$ in this equation as a linear function generated from $p$:

$q = ap(p) + cp\ mod\ m$

Now we can plug in $q$, $p$ into $n$:

$n = p \dot q = p(ap(p) + cp) = ap(p)^2 + cp(p)$

Therefore this can be represented as a quadratic equation:

$ap(p)^2 + cp(p) - n = 0$

Now it is possible to solve for $p$ and $q$ through quadratic congruence, using the given parameters of $a$, $c$, $m$ and $n$. 

## Exploitation

**Exploit overview**: The challenge has us exploit the weakness of PRNGs in generating primes for cryptographic applications. Since LCGs are linear relations, their product is a quadratic relation which can be recovered by solving the quadratic roots. This weakness allows us to factor $n$, which in textbook RSA allows for easy recovery of the private key and the ability to decrypt any message.

**Exploit mitigation considerations**: Mitigations could be considered where the parameters are not given or where RSA is padded instead of just textbook RSA. This makes it more difficult to recover the private key or decrypt messages, but does not completely remediate the issue.

**Exploit description**: 

**Exploit primitives used**:
1. LCG State recovery (predictability of PRNGs)
2. RSA Factorization via $p, q$ recovery

## Remediation

A good start to remediation would be only using Cryptographically Secure PRNGs (CSPRNGs) like ```os.urandom()```, ```/dev/random```, or ```secrets``` instead of LCGs. However, this does not guarantee that the resulting RSA implementation will be secure. 

Using padding in RSA can mitigate attacks on RSA, as well as using a 2048-bit key instead of the 1024-bit one used in this implementation. However, even with padding or a longer key, the schema will still be susceptible to the predictability of LCG, and RSA can potentially be cracked through additional information leaks. This implementation is particularly weak since the parameters are given in the program which allows us to calculate the values of p and q.


